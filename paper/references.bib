
@software{2020,
  title = {Reduxjs/Redux-Devtools},
  date = {2020-05-11T13:54:05Z},
  origdate = {2015-07-05T10:58:49Z},
  url = {https://github.com/reduxjs/redux-devtools},
  urldate = {2020-05-11},
  abstract = {DevTools for Redux with hot reloading, action replay, and customizable UI},
  organization = {{Redux}}
}

@inproceedings{brown1984,
  title = {A System for Algorithm Animation},
  booktitle = {Proceedings of the 11th Annual Conference on {{Computer}} Graphics and Interactive Techniques},
  author = {Brown, Marc H. and Sedgewick, Robert},
  date = {1984-01-01},
  pages = {177--186},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/800031.808596},
  url = {http://doi.org/10.1145/800031.808596},
  urldate = {2020-05-11},
  abstract = {A software environment is described which provides facilities at a variety of levels for “animating” algorithms: exposing properties of programs by displaying multiple dynamic views of the program and associated data structures. The system is operational on a network of graphics-based, personal workstations and has been used successfully in several applications for teaching and research in computer science and mathematics. In this paper, we outline the conceptual framework that we have developed for animating algorithms, describe the system that we have implemented, and give several examples drawn from the host of algorithms that we have animated.},
  file = {/Users/geoffreylitt/Zotero/storage/4XLPNHXX/Brown and Sedgewick - 1984 - A system for algorithm animation.pdf},
  isbn = {978-0-89791-138-2},
  series = {{{SIGGRAPH}} '84}
}

@online{czaplicki,
  title = {The {{Elm Architecture}} · {{An Introduction}} to {{Elm}}},
  author = {Czaplicki, Evan},
  url = {https://guide.elm-lang.org/architecture/},
  urldate = {2020-05-11},
  file = {/Users/geoffreylitt/Zotero/storage/P4VFX8C7/architecture.html}
}

@article{fowler2020,
  title = {Model-{{View}}-{{Update}}-{{Communicate}}: {{Session Types}} Meet the {{Elm Architecture}}},
  shorttitle = {Model-{{View}}-{{Update}}-{{Communicate}}},
  author = {Fowler, Simon},
  date = {2020-01-13},
  url = {http://arxiv.org/abs/1910.11108},
  urldate = {2020-05-11},
  abstract = {Session types are a type discipline for communication channel endpoints which allow conformance to protocols to be checked statically. Safely implementing session types requires linearity, usually in the form of a linear type system. Unfortunately, linear typing is difficult to integrate with graphical user interfaces (GUIs), and to date most programs using session types are command line applications. In this paper, we propose the first principled integration of session typing and GUI development by building upon the Model-View-Update (MVU) architecture, pioneered by the Elm programming language. We introduce \$\textbackslash{}lambda\_\{\textbackslash{}textsf\{MVU\}\}\$, the first formal model of the MVU architecture, and prove it sound. By extending \$\textbackslash{}lambda\_\{\textbackslash{}textsf\{MVU\}\}\$ with \textbackslash{}emph\{commands\} as found in Elm, along with \textbackslash{}emph\{linearity\} and \textbackslash{}emph\{model transitions\}, we show the first formal integration of session typing and GUI programming. We implement our approach in the Links web programming language, and show examples including a two-factor authentication workflow and multi-room chat server.},
  archivePrefix = {arXiv},
  eprint = {1910.11108},
  eprinttype = {arxiv},
  file = {/Users/geoffreylitt/Zotero/storage/689LC7JQ/Fowler - 2020 - Model-View-Update-Communicate Session Types meet .pdf;/Users/geoffreylitt/Zotero/storage/NFXV2J5L/1910.html},
  keywords = {Computer Science - Programming Languages},
  primaryClass = {cs}
}

@inproceedings{hoffswell2018a,
  title = {Augmenting {{Code}} with {{In Situ Visualizations}} to {{Aid Program Understanding}}},
  booktitle = {Proceedings of the 2018 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Hoffswell, Jane and Satyanarayan, Arvind and Heer, Jeffrey},
  date = {2018-04-21},
  pages = {1--12},
  publisher = {{Association for Computing Machinery}},
  location = {{Montreal QC, Canada}},
  doi = {10.1145/3173574.3174106},
  url = {http://doi.org/10.1145/3173574.3174106},
  urldate = {2020-05-11},
  abstract = {Programmers must draw explicit connections between their code and runtime state to properly assess the correctness of their programs. However, debugging tools often decouple the program state from the source code and require explicitly invoked views to bridge the rift between program editing and program understanding. To unobtrusively reveal runtime behavior during both normal execution and debugging, we contribute techniques for visualizing program variables directly within the source code. We describe a design space and placement criteria for embedded visualizations. We evaluate our in situ visualizations in an editor for the Vega visualization grammar. Compared to a baseline development environment, novice Vega users improve their overall task grade by about 2 points when using the in situ visualizations and exhibit significant positive effects on their self-reported speed and accuracy.},
  file = {/Users/geoffreylitt/Zotero/storage/YHWWBVN2/Hoffswell et al. - 2018 - Augmenting Code with In Situ Visualizations to Aid.pdf},
  isbn = {978-1-4503-5620-6},
  keywords = {code augmentation,debugging,program behavior,program understanding,visualization},
  series = {{{CHI}} '18}
}

@inproceedings{kang2017,
  title = {Omnicode: {{A Novice}}-{{Oriented Live Programming Environment}} with {{Always}}-{{On Run}}-{{Time Value Visualizations}}},
  shorttitle = {Omnicode},
  booktitle = {Proceedings of the 30th {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  author = {Kang, Hyeonsu and Guo, Philip J.},
  date = {2017-10-20},
  pages = {737--745},
  publisher = {{ACM}},
  location = {{Québec City QC Canada}},
  doi = {10.1145/3126594.3126632},
  url = {https://dl.acm.org/doi/10.1145/3126594.3126632},
  urldate = {2020-05-07},
  abstract = {Visualizations of run-time program state help novices form proper mental models and debug their code. We push this technique to the extreme by posing the following question: What if a live programming environment for an imperative language always displays the entire history of all run-time values for all program variables all the time? To explore this question, we built a prototype live IDE called Omnicode (“Omniscient Code”) that continually runs the user’s Python code and uses a scatterplot matrix to visualize the entire history of all of its numerical values, along with meaningful numbers derived from other data types. To filter the visualizations and hone in on specific points of interest, the user can brush and link over the scatterplots or select portions of code. They can also zoom in to view detailed stack and heap visualizations at each execution step. An exploratory study on 10 novice programmers discovered that they found Omnicode to be useful for debugging, forming mental models, explaining their code to others, and discovering moments of serendipity that would not have been likely within an ordinary IDE.},
  eventtitle = {{{UIST}} '17: {{The}} 30th {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  file = {/Users/geoffreylitt/Zotero/storage/PDKJMA9H/Kang and Guo - 2017 - Omnicode A Novice-Oriented Live Programming Envir.pdf},
  isbn = {978-1-4503-4981-9},
  keywords = {program visualization},
  langid = {english}
}

@inproceedings{ko2004,
  title = {Designing the Whyline: A Debugging Interface for Asking Questions about Program Behavior},
  shorttitle = {Designing the Whyline},
  booktitle = {Proceedings of the 2004 Conference on {{Human}} Factors in Computing Systems  - {{CHI}} '04},
  author = {Ko, Andrew J. and Myers, Brad A.},
  date = {2004},
  pages = {151--158},
  publisher = {{ACM Press}},
  location = {{Vienna, Austria}},
  doi = {10.1145/985692.985712},
  url = {http://portal.acm.org/citation.cfm?doid=985692.985712},
  urldate = {2020-05-07},
  abstract = {Debugging is still among the most common and costly of programming activities. One reason is that current debugging tools do not directly support the inquisitive nature of the activity. Interrogative Debugging is a new debugging paradigm in which programmers can ask why did and even why didn’t questions directly about their program’s runtime failures. The Whyline is a prototype Interrogative Debugging interface for the Alice programming environment that visualizes answers in terms of runtime events directly relevant to a programmer’s question. Comparisons of identical debugging scenarios from user tests with and without the Whyline showed that the Whyline reduced debugging time by nearly a factor of 8, and helped programmers complete 40\% more tasks.},
  eventtitle = {The 2004 Conference},
  file = {/Users/geoffreylitt/Zotero/storage/4PRZXVG7/Ko and Myers - 2004 - Designing the whyline a debugging interface for a.pdf},
  isbn = {978-1-58113-702-6},
  keywords = {program visualization},
  langid = {english}
}

@article{lerner,
  title = {Projection {{Boxes}}: {{On}}-the-Fly {{Reconfigurable Visualization}} for {{Live Programming}}},
  author = {Lerner, Sorin},
  pages = {7},
  abstract = {Live programming is a regime in which the programming environment provides continual feedback, most often in the form of runtime values. In this paper, we present Projection Boxes, a novel visualization technique for displaying runtime values of programs. The key idea behind projection boxes is to start with a full semantics of the program, and then use projections to pick a subset of the semantics to display. By varying the projection used, projection boxes can encode both previously known visualization techniques, and also new ones. As such, projection boxes provide an expressive and configurable framework for displaying runtime information. Through a user study we demonstrate that (1) users find projection boxes and their configurability useful (2) users are not distracted by the always-on visualization (3) a key driving force behind the need for a configurable visualization for live programming lies with the wide variation in programmer preferences.},
  file = {/Users/geoffreylitt/Zotero/storage/N3IBF8AI/Lerner - Projection Boxes On-the-fly Reconfigurable Visual.pdf},
  keywords = {program visualization},
  langid = {english}
}

@inproceedings{lerner2020,
  title = {Projection {{Boxes}}: {{On}}-the-Fly {{Reconfigurable Visualization}} for {{Live Programming}}},
  shorttitle = {Projection {{Boxes}}},
  booktitle = {Proceedings of the 2020 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Lerner, Sorin},
  date = {2020},
  publisher = {{Association for Computing Machinery}},
  doi = {10.1145/3313831.3376494},
  abstract = {Live programming is a regime in which the programming environment provides continual feedback, most often in the form of runtime values. In this paper, we present Projection Boxes, a novel visualization technique for displaying runtime values of programs. The key idea behind projection boxes is to start with a full semantics of the program, and then use projections to pick a subset of the semantics to display. By varying the projection used, projection boxes can encode both previously known visualization techniques, and also new ones. As such, projection boxes provide an expressive and configurable framework for displaying runtime information. Through a user study we demonstrate that (1) users find projection boxes and their configurability useful (2) users are not distracted by the always-on visualization (3) a key driving force behind the need for a configurable visualization for live programming lies with the wide variation in programmer preferences.}
}

@inproceedings{lieber2014,
  title = {Addressing Misconceptions about Code with Always-on Programming Visualizations},
  booktitle = {Proceedings of the 32nd Annual {{ACM}} Conference on {{Human}} Factors in Computing Systems - {{CHI}} '14},
  author = {Lieber, Tom and Brandt, Joel R. and Miller, Rob C.},
  date = {2014},
  pages = {2481--2490},
  publisher = {{ACM Press}},
  location = {{Toronto, Ontario, Canada}},
  doi = {10.1145/2556288.2557409},
  url = {http://dl.acm.org/citation.cfm?doid=2556288.2557409},
  urldate = {2020-05-11},
  abstract = {We present Theseus, an IDE extension that visualizes run­ time behavior within a JavaScript code editor. By displaying real-time information about how code actually behaves dur­ ing execution, Theseus proactively addresses misconceptions by drawing attention to similarities and differences between the programmer’s idea of what code does and what it actu­ ally does. To understand how programmers would respond to this kind of an always-on visualization, we ran a lab study with graduate students, and interviewed 9 professional pro­ grammers who were asked to use Theseus in their day-to-day work. We found that users quickly adopted strategies that are unique to always-on, real-time visualizations, and used the additional information to guide their navigation through their code.},
  eventtitle = {The 32nd Annual {{ACM}} Conference},
  file = {/Users/geoffreylitt/Zotero/storage/44LDG267/Lieber et al. - 2014 - Addressing misconceptions about code with always-o.pdf},
  isbn = {978-1-4503-2473-1},
  langid = {english}
}

@inproceedings{meyer2006,
  title = {Mondrian: An Agile Information Visualization Framework},
  shorttitle = {Mondrian},
  booktitle = {Proceedings of the 2006 {{ACM}} Symposium on {{Software}} Visualization  - {{SoftVis}} '06},
  author = {Meyer, Michael and Gîrba, Tudor and Lungu, Mircea},
  date = {2006},
  pages = {135},
  publisher = {{ACM Press}},
  location = {{Brighton, United Kingdom}},
  doi = {10.1145/1148493.1148513},
  url = {http://portal.acm.org/citation.cfm?doid=1148493.1148513},
  urldate = {2020-05-11},
  abstract = {Data visualization is the process of representing data as pictures to support reasoning about the underlying data. For the interpretation to be as easy as possible, we need to be as close as possible to the original data. As most visualization tools have an internal metamodel, which is different from the one for the presented data, they usually need to duplicate the original data to conform to their metamodel. This leads to an increase in the resources needed, increase which is not always justified. In this work we argue for the need of having an engine that is as close as possible to the data and we present our solution of moving the visualization tool to the data, instead of moving the data to the visualization tool. Our solution also emphasizes the necessity of reusing basic blocks to express complex visualizations and allowing the programmer to script the visualization using his preferred tools, rather than a third party format. As a validation of the expressiveness of our framework, we show how we express several already published visualizations and describe the pros and cons of the approach.},
  eventtitle = {The 2006 {{ACM}} Symposium},
  file = {/Users/geoffreylitt/Zotero/storage/SPYK98W2/Meyer et al. - 2006 - Mondrian an agile information visualization frame.pdf},
  isbn = {978-1-59593-464-2},
  langid = {english}
}

@article{myers1983,
  title = {{{INCENSE}}: {{A}} System for Displaying Data Structures},
  shorttitle = {{{INCENSE}}},
  author = {Myers, Brad A.},
  date = {1983-07-01},
  journaltitle = {ACM SIGGRAPH Computer Graphics},
  shortjournal = {SIGGRAPH Comput. Graph.},
  volume = {17},
  pages = {115--125},
  issn = {0097-8930},
  doi = {10.1145/964967.801140},
  url = {http://doi.org/10.1145/964967.801140},
  urldate = {2020-05-11},
  abstract = {Many modern computer languages allow the programmer to define and use a variety of data types. Few programming systems, however, allow the programmer similar flexibility when displaying the data structures for debugging, monitoring and documenting programs. Incense is a working prototype system that allows the programmer to interactively investigate data structures in actual programs. The desired displays can be specified by the programmer or a default can be used. The default displays provided by Incense present the standard form for literals of the basic types, the actual names for scalar types, stacked boxes for records and arrays, and curved lines with arrowheads for pointers. In addition to displaying data structures, Incense also allows the user to select, move, erase and redimension the resulting displays. These interactions are provided in a uniform, natural manner using a pointing device (mouse) and keyboard.},
  file = {/Users/geoffreylitt/Zotero/storage/GQIVMKPW/Myers - 1983 - INCENSE A system for displaying data structures.pdf},
  number = {3}
}

@article{myers1990,
  title = {Taxonomies of Visual Programming and Program Visualization},
  author = {Myers, Brad A.},
  date = {1990-03},
  journaltitle = {Journal of Visual Languages \& Computing},
  shortjournal = {Journal of Visual Languages \& Computing},
  volume = {1},
  pages = {97--123},
  issn = {1045926X},
  doi = {10.1016/S1045-926X(05)80036-9},
  url = {https://linkinghub.elsevier.com/retrieve/pii/S1045926X05800369},
  urldate = {2020-04-28},
  abstract = {There has been a great interest recently in systems that use graphics to aid in the programming, debugging, and understanding of computer systems. The terms ‘‘Visual Programming’’ and ‘‘Program Visualization’’ have been applied to these systems. This paper attempts to provide more meaning to these terms by giving precise definitions, and then surveys a number of systems that can be classified as providing Visual Programming or Program Visualization. These systems are organized by classifying them into three different taxonomies.},
  file = {/Users/geoffreylitt/Zotero/storage/RRUVMERM/Myers - 1990 - Taxonomies of visual programming and program visua.pdf},
  keywords = {program visualization},
  langid = {english},
  number = {1}
}

@inproceedings{pollock2019,
  title = {Theia: Automatically Generating Correct Program State Visualizations},
  shorttitle = {Theia},
  booktitle = {Proceedings of the 2019 {{ACM SIGPLAN Symposium}} on {{SPLASH}}-{{E}}  - {{SPLASH}}-{{E}} 2019},
  author = {Pollock, Josh and Roesch, Jared and Woos, Doug and Tatlock, Zachary},
  date = {2019},
  pages = {46--56},
  publisher = {{ACM Press}},
  location = {{Athens, Greece}},
  doi = {10.1145/3358711.3361625},
  url = {http://dl.acm.org/citation.cfm?doid=3358711.3361625},
  urldate = {2020-01-28},
  abstract = {Program state visualizations (PSVs) help programmers understand hidden program state like objects, references, and closures. Unfortunately, existing PSV tools do not support custom language semantics, which educators often use to introduce programming languages gradually. They also fail to visualize key pieces of program state, which can lead to incorrect and confusing visualizations.},
  eventtitle = {The 2019 {{ACM SIGPLAN Symposium}}},
  file = {/Users/geoffreylitt/Zotero/storage/FNAG6CMM/Pollock et al. - 2019 - Theia automatically generating correct program st.pdf},
  isbn = {978-1-4503-6989-3},
  langid = {english}
}

@inproceedings{reiss2003,
  title = {{{JIVE}}: Visualizing {{Java}} in Action Demonstration Description},
  shorttitle = {{{JIVE}}},
  booktitle = {Proceedings of the 25th {{International Conference}} on {{Software Engineering}}},
  author = {Reiss, Steven P.},
  date = {2003-05-03},
  pages = {820--821},
  publisher = {{IEEE Computer Society}},
  location = {{Portland, Oregon}},
  abstract = {Dynamic software visualization should provide a programmer with insights as to what the program is doing. Most current dynamic visualizations either use program traces to show information about prior runs, slow the program down substantially, show only minimal information, or force the programmer to indicate when to turn visualizations on or off. We have developed a dynamic Java visualizer that provides a view of a program in action with low enough overhead that it can be used almost all the time by programmers to understand what their program is doing while it is doing it.},
  file = {/Users/geoffreylitt/Zotero/storage/X42G8K2G/Reiss - 2003 - JIVE visualizing Java in action demonstration des.pdf},
  isbn = {978-0-7695-1877-0},
  series = {{{ICSE}} '03}
}

@inproceedings{reiss2005,
  title = {Jove: Java as It Happens},
  shorttitle = {Jove},
  booktitle = {Proceedings of the 2005 {{ACM}} Symposium on {{Software}} Visualization  - {{SoftVis}} '05},
  author = {Reiss, Steven P. and Renieris, Manos},
  date = {2005},
  pages = {115},
  publisher = {{ACM Press}},
  location = {{St. Louis, Missouri}},
  doi = {10.1145/1056018.1056034},
  url = {http://portal.acm.org/citation.cfm?doid=1056018.1056034},
  urldate = {2020-05-11},
  abstract = {Dynamic software visualization is designed to provide programmers with insights as to what the program is doing. Most current dynamic visualizations either use program traces to show information about prior runs, slow the program down substantially, show only minimal information, or force the programmer to indicate when to turn visualizations on or off. We have developed a dynamic Java visualizer that provides a statement-level view of a Java program in action with low enough overhead so that it can be used almost all the time by programmers to understand what their program is doing while it is doing it.},
  eventtitle = {The 2005 {{ACM}} Symposium},
  file = {/Users/geoffreylitt/Zotero/storage/V8H4ET9K/Reiss and Renieris - 2005 - Jove java as it happens.pdf},
  isbn = {978-1-59593-073-6},
  langid = {english}
}

@article{reiss2007,
  title = {Visual Representations of Executing Programs},
  author = {Reiss, Steven P.},
  date = {2007},
  journaltitle = {J. Vis. Lang. Comput.},
  doi = {10.1016/j.jvlc.2007.01.003},
  abstract = {Programmers have always been curious about what their programs are doing while it is executing, especially when the behavior is not what they are expecting. Since program execution is intricate and involved, visualization has long been used to provide the programmer with appropriate insights into program execution. This paper looks at the evolution of on-line visual representations of executing programs, showing how they have moved from concrete representations of relatively small programs to abstract representations of larger systems. Based on this examination, we describe the challenges implicit in future execution visualizations and methodologies that can meet these challenges.},
  file = {/Users/geoffreylitt/Zotero/storage/28TMHIMW/jvlexec-1.pdf}
}

@article{stasko1990,
  title = {Tango: {{A Framework}} and {{System}} for {{Algorithm Animation}}},
  shorttitle = {Tango},
  author = {Stasko, John T.},
  date = {1990-09-01},
  journaltitle = {Computer},
  shortjournal = {Computer},
  volume = {23},
  pages = {27--39},
  issn = {0018-9162},
  doi = {10.1109/2.58216},
  url = {http://doi.org/10.1109/2.58216},
  urldate = {2020-05-11},
  abstract = {The role of animation in understanding and evaluating programs and developing new programs is discussed. A framework for algorithm animation, called Tango, and a system based on that framework are introduced. Related work is reviewed, and the conceptual framework on which Tango is based is examined. The implementation of the Tango system is described. The first-fit bin-packing algorithm is animated to illustrate how the path-transition paradigm simplifies algorithm animation.},
  number = {9}
}

@online{victora,
  title = {Learnable {{Programming}}},
  author = {Victor, Bret},
  url = {http://worrydream.com/LearnableProgramming/},
  urldate = {2020-04-28},
  file = {/Users/geoffreylitt/Zotero/storage/TD257V6J/LearnableProgramming.html},
  keywords = {program visualization}
}


